<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法学习之递归]]></title>
    <url>%2F2019%2F08%2F03%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归（Recursion）,在数学与计算机科学中是指在函数的定义中有调用了函数自身的方法。是一种思考问题的方法，通过递归可以简化问题的定义。 递归的本质递归本质是缩小问题规模。把大规模的问题逐步缩小，小到一定程度可以直接得出它的解。 递归能解决哪些问题能使用递归解决的问题，有三个特点： 每一次递归调用，规模都应该缩小 两次递归调用之间有紧密的联系，前一次要为后一次递归调用做准备 在问题规模极小的时候可以直接给出解答 递归需要考虑的两个方面： 确定递归公式，如何缩减规模 确定边界条件，如何得到边界值 递归的应用一下是理解了递归的思想后，用JS实现的一些基础算法 计算最大公约数12345678910// 使用辗转相除法 M mod N = R，用N mod R递归，直到余数为零function gcd (m,n) &#123; if(typeof m !== &apos;number&apos; || typeof n !== &apos;number&apos;) return; let r = m % n; if(r === 0) &#123; return n; &#125; else &#123; return gcd(n,r); &#125;&#125; 计算阶乘12345678function fact(n) &#123; if(typeof n !== &apos;number&apos;) return; if(n === 0) &#123; return 1; &#125;else&#123; return n * fact(n-1); &#125;&#125;]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue源码深入剖析之响应式系统]]></title>
    <url>%2F2019%2F08%2F03%2Fvue%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Vue.js作为一款十分流行mvvm框架，数据模型（vm）部分都是普通的js对象，但是对这些对象进行操作的时候，却能影响视图（v）。实现这一连接的就是「响应式系统」，Vue最核心的部分就是「响应式系统」。虽然日常使用中并不会修改「响应式系统」，但是深入学习它可以帮助我们了解之后有可能遇到的问题的根源，从而更好的解决问题。 基本原理篇首先我们找到vue的目录，看到core文件夹下的目录结构如下： 「响应式系统」的所有源码都在observer文件夹下。为了更好的理解，之后的分析会把此文件夹下的代码由简入繁的展示。 1. Object.defineProperty说到Vue的「响应式系统」，首先必须介绍一下Object.defineProperty, Vue就是基于他来实现「响应式系统」的。 1234567/*obj: 目标对象prop: 需要操作的目标对象的属性名 descriptor: 描述符return value 传入对象 */Object.defineProperty(obj, prop, descriptor) 其中，简单介绍descriptor 的一些属性，这些在Vue中被使用。 enumerable属性是否可枚举，默认 false。 configurable属性是否可以被修改或者删除，默认 false。 get获取属性的方法。 set设置属性的方法。 2. 把对象响应式化（defineReactive）知道了Object.defineProperty以后，Vue用它使对象变成可观察的。 由于源码中defineReactive有很多功能，较为复杂，我们可以先简单的实现一个： 12345678910111213function defineReactive (obj, key, val) &#123; Object.defineProperty(obj, key, &#123; enumerable: true, /* 属性可枚举 */ configurable: true, /* 属性可被修改或删除 */ get: function reactiveGetter () &#123; return val; &#125;, set: function reactiveSetter (newVal) &#123; if (newVal === val) return; callback(newVal); &#125; &#125;);&#125; 其中callback是回调方法，这个函数用来模拟视图更新，调用它即代表更新视图。此处我们就随便写一个 123function callback (val) &#123; console.log(&quot;视图更新！&quot;); &#125; 经过defineReactive处理以后，我们的obj的key属性在「读」的时候会触发reactiveGetter方法，而在该属性被「写」的时候则会触发 reactiveSetter方法。 3. Observer有了前面的defineReactive，我们需要在上面再封装一层observer。 由于源码中observer有很多功能，较为复杂，我们可以先简单的实现一个： 12345678function observer (value) &#123; if (!value || (typeof value !== &apos;object&apos;)) &#123; return; &#125; Object.keys(value).forEach((key) =&gt; &#123; defineReactive(value, key, value[key]); &#125;)&#125; 这个函数传入一个 value(需要「响应式」化的对象)，通过遍历所有属性的方式对该对象的每一个属性都通过defineReactive处理。 原理的基础实现有了上述的模块，我们就可以简单的实现一个「响应式系统」了，也可以说实现一个Vue的雏形 123456class Vue &#123; constructor(options) &#123; this.data = options.data; observer(this.data); &#125;&#125; 在 Vue 的构造函数中，对options的data进行处理，这里的data想必大家很熟悉，就是平时我们在写Vue项目时组件中的data属性(实际上是一个函数，这里当作一个对象来简单处理)。 然后我们把他实例化，并且修改一下被响应式化了的属性 123456let app = new Vue(&#123; data: &#123; test: &quot;I am test.&quot; &#125;&#125;);app.data.test = &quot;hello,world.&quot;; 你会看到console里输出了之前callback函数的语句——“视图更新！” 至此，响应式原理已经介绍完了 思考一个简单的响应式系统完成了，可是它还有很多的问题，比如： 如果视图上并不需要用到的属性imnouse更新了，我们这个雏形中也仍然会执行callback操作。 在有多个视图共享同一个数据模型的时候，属性imveryfamous被view1和view2视图实例用来展示。此时imveryfamous改变了，需要准确的通知到view1和view2，而不要通知其他的视图。 这就需要用到下一篇要说的「依赖收集」，它是「响应式系统」很重要的一个功能，源码也放置在core\observer文件夹中。]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
