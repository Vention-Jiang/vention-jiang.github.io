<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue源码深入剖析之依赖收集]]></title>
    <url>%2F2019%2F08%2F05%2Fvue%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[上一篇文章我们用一个简化之后简单实现作为例子，实现了一个简单的「响应式系统」。 但这个例子有许多问题需要解决，比如： 如果视图上并不需要用到的属性imnouse更新了，我们这个雏形中也仍然会执行callback操作。 在有多个视图共享同一个数据模型的时候，属性imveryfamous被view1和view2视图实例用来展示。此时imveryfamous改变了，需要准确的通知到view1和view2，而不要通知其他的视图。 为了解决这些问题，我们为之前的简单示例添加「依赖收集」的功能。 基本原理篇在vue的目录，看到core文件夹下的目录结构如下： 今天要说的「依赖收集」的代码就在core/observer/watcher.js和core/observer/dep.js中。同样，由于源码中的实现较为全面，本文会以做了大量的简化之后简单实现来作为示例。 「依赖收集」的关系如下图所示。每个响应式对象都有一个订阅者Dep，用来存放订阅的watcher。当对象被读取（get）时，当前的watcher会被压入Dep中添加依赖，而每个watcher都是一个观察者，当对象被修改（set）时，会执行所有依赖的watcher的callback。 1. 订阅者Dep我们先简单的实现一个订阅者Dep，它主要用来存放watcher 1234567891011121314151617181920class Dep &#123; constructor() &#123; /* 用来存放 Watcher 对象的数组 */ this.subs = []; &#125; /* 在 subs 中添加一个 Watcher 对象 */ addSub(sub) &#123; this.subs.push(sub); &#125; /* 通知所有 Watcher 对象更新视图 */ notify() &#123; this.subs.forEach((sub) = &gt;&#123; sub.update(); &#125;) &#125;,&#125;export function setTarget (_target) &#123; Dep.target = _target&#125;Dep.target = null Dep中有两个方法，分别是： addSub添加订阅者，实际应用时就是把当前的watcher添加到Dep对象的订阅者数组中去 notify的方法，通知Dep中所有的订阅者去触发他们的更新操作 2. 观察者Watcher再来简单的实现一个watcher， 1234567891011import &#123; pushTarget &#125; from &apos;./dep&apos;class Watcher &#123; constructor() &#123; /* 在 new 一个 Watcher 对象时将该对象通过pushTarget方法，设置为当前target，在 get 中会用到 */ setTarget(this); &#125; /* 更新视图的方法 */ update() &#123; console.log(&quot;视图更新啦~&quot;); &#125;&#125; 3. 修改defineReactive我们增加了一个Dep类的对象，用来收集watcher对象。在对象被「读」的时候，会触发reactiveGetter函数把当前的Watcher对象(存放在Dep.target 中)收集到Dep类中去。之后如果当该对象被「写」的时候，则会触发reactiveSetter方法，通知Dep类调用notify来触发所有Watcher对象的update方法更新对应视图 123456789101112131415161718function defineReactive(obj, key, val) &#123; /* 一个Dep类对象 */ const dep = new Dep(); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; /* 将 Dep.target(即当前的 Watcher 对象存入 dep 的 subs 中) */ dep.addSub(Dep.target); return val; &#125;, set: function reactiveSetter(newVal) &#123; if (newVal === val) return; /* 在 set 的时候触发 dep 的 notify 来通知所有的 Watcher 对象更新视图 */ dep.notify(); &#125; &#125;);&#125; 原理的基础实现我们修改一下之前的Vue 12345678910class Vue &#123; constructor(options) &#123; this._data = options.data; observer(this._data); /* 新建一个 Watcher 观察者对象，这时候 Dep.target 会指向这个 Watcher 对象 */ new Watcher(); /* 在这里模拟 render 的过程，为了触发 test 属性的 get 函数 */ console.log(&apos;render~&apos;, this._data.test); &#125;&#125; 首先在observer的过程中会注册get方法，该方法用来进行「依赖收集」。在它的闭包中会有一个Dep对象，这个对象用来存放Watcher对象的实例。其实「依赖收集」的过程就是把Watcher实例存放到对应的Dep对象中去。get方法可以让当前的Watcher对象 (Dep.target)存放到它的subs中 (addSub)方法，在数据变化时，set会调用Dep对象的notify方法通知它内部所有的Watcher对象进行视图更新。 这是Object.defineProperty的set / get方法处理的事情，那么「依赖收集」的前提条件还有两个: 触发get方法 新建一个Watcher对象 这个我们在Vue的构造类中处理。新建一个Watcher对象只需要new出来，这时候Dep.target已经指向了这个new出来的Watcher对象来。而触发get方法也很简单，实际上只要把renderfunction进行渲染，那么其中的依赖的对象都会被「读取」，这里我们通过打印来模拟这个过程，读取test来触发get进行「依赖收集」。 小结至此，简单的「响应式系统」就已经建立起来了，他可以通过get来进行「依赖收集」，然后通过set来通知观察者更新视图。]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法学习之递归]]></title>
    <url>%2F2019%2F08%2F03%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归（Recursion）,在数学与计算机科学中是指在函数的定义中有调用了函数自身的方法。是一种思考问题的方法，通过递归可以简化问题的定义。 递归的本质递归本质是缩小问题规模。把大规模的问题逐步缩小，小到一定程度可以直接得出它的解。 递归能解决哪些问题能使用递归解决的问题，有三个特点： 每一次递归调用，规模都应该缩小 两次递归调用之间有紧密的联系，前一次要为后一次递归调用做准备 在问题规模极小的时候可以直接给出解答 递归需要考虑的两个方面： 确定递归公式，如何缩减规模 确定边界条件，如何得到边界值 递归的应用一下是理解了递归的思想后，用JS实现的一些基础算法 计算最大公约数12345678910// 使用辗转相除法 M mod N = R，用N mod R递归，直到余数为零function gcd (m,n) &#123; if(typeof m !== &apos;number&apos; || typeof n !== &apos;number&apos;) return; let r = m % n; if(r === 0) &#123; return n; &#125; else &#123; return gcd(n,r); &#125;&#125; 计算阶乘12345678function fact(n) &#123; if(typeof n !== &apos;number&apos;) return; if(n === 0) &#123; return 1; &#125;else&#123; return n * fact(n-1); &#125;&#125;]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue源码深入剖析之响应式系统]]></title>
    <url>%2F2019%2F08%2F03%2Fvue%E6%BA%90%E7%A0%81%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[Vue.js作为一款十分流行mvvm框架，数据模型（vm）部分都是普通的js对象，但是对这些对象进行操作的时候，却能影响视图（v）。实现这一连接的就是「响应式系统」，Vue最核心的部分就是「响应式系统」。虽然日常使用中并不会修改「响应式系统」，但是深入学习它可以帮助我们了解之后有可能遇到的问题的根源，从而更好的解决问题。 基本原理篇首先我们找到vue的目录，看到core文件夹下的目录结构如下： 「响应式系统」的所有源码都在observer文件夹下。为了更好的理解，之后的分析会把此文件夹下的代码由简入繁的展示。 今天要说的「响应式系统」的代码就在core/observer/index.js中。由于源码中的实现较为全面，本文会以做了大量的简化之后简单实现来作为示例。 1. Object.defineProperty说到Vue的「响应式系统」，首先必须介绍一下Object.defineProperty, Vue就是基于他来实现「响应式系统」的。 1234567/*obj: 目标对象prop: 需要操作的目标对象的属性名 descriptor: 描述符return value 传入对象 */Object.defineProperty(obj, prop, descriptor) 其中，简单介绍descriptor 的一些属性，这些在Vue中被使用。 enumerable属性是否可枚举，默认 false。 configurable属性是否可以被修改或者删除，默认 false。 get获取属性的方法。 set设置属性的方法。 2. 把对象响应式化（defineReactive）知道了Object.defineProperty以后，Vue用它使对象变成可观察的。 我们可以先简单的实现一个： 12345678910111213function defineReactive (obj, key, val) &#123; Object.defineProperty(obj, key, &#123; enumerable: true, /* 属性可枚举 */ configurable: true, /* 属性可被修改或删除 */ get: function reactiveGetter () &#123; return val; &#125;, set: function reactiveSetter (newVal) &#123; if (newVal === val) return; callback(newVal); &#125; &#125;);&#125; 其中callback是回调方法，这个函数用来模拟视图更新，调用它即代表更新视图。此处我们就随便写一个 123function callback (val) &#123; console.log(&quot;视图更新！&quot;); &#125; 经过defineReactive处理以后，我们的obj的key属性在「读」的时候会触发reactiveGetter方法，而在该属性被「写」的时候则会触发 reactiveSetter方法。 3. Observer有了前面的defineReactive，我们需要在上面再封装一层observer。 我们可以先简单的实现一个： 12345678function observer (value) &#123; if (!value || (typeof value !== &apos;object&apos;)) &#123; return; &#125; Object.keys(value).forEach((key) =&gt; &#123; defineReactive(value, key, value[key]); &#125;)&#125; 这个函数传入一个 value(需要「响应式」化的对象)，通过遍历所有属性的方式对该对象的每一个属性都通过defineReactive处理。 原理的基础实现有了上述的模块，我们就可以简单的实现一个「响应式系统」了，也可以说实现一个Vue的雏形 123456class Vue &#123; constructor(options) &#123; this.data = options.data; observer(this.data); &#125;&#125; 在 Vue 的构造函数中，对options的data进行处理，这里的data想必大家很熟悉，就是平时我们在写Vue项目时组件中的data属性(实际上是一个函数，这里当作一个对象来简单处理)。 然后我们把他实例化，并且修改一下被响应式化了的属性 123456let app = new Vue(&#123; data: &#123; test: &quot;I am test.&quot; &#125;&#125;);app.data.test = &quot;hello,world.&quot;; 你会看到console里输出了之前callback函数的语句——“视图更新！” 至此，响应式原理已经介绍完了 思考一个简单的响应式系统完成了，可是它还有很多的问题，比如： 如果视图上并不需要用到的属性imnouse更新了，我们这个雏形中也仍然会执行callback操作。 在有多个视图共享同一个数据模型的时候，属性imveryfamous被view1和view2视图实例用来展示。此时imveryfamous改变了，需要准确的通知到view1和view2，而不要通知其他的视图。 这就需要用到下一篇要说的「依赖收集」，它是「响应式系统」很重要的一个功能，源码也放置在core\observer文件夹中。]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
